===============================
Описание архитектуры системы
===============================

Введение
~~~~~~~~~~~

Система базируется на микросервисной архитектуре, так как это упростит горизонтальное масштабирование и разделение сервисов.

Каждый сервис владеет своей собственной моделью данных и базой данных.

Протокол обмена сообщениями - Websocket, протокол обмена дополнительной информацией - REST API или GrpahQL.

Синхронное взаимодействие между сервисами осуществляется по протоколу gRPC.

Асинхронное взаимодействие между сервисами осуществляется с использованием брокера сообщений (например, Kafka).

Для работы с различными клиентами применяется паттерн BFF (Backend-for-Frontend).

Все микросервисы проектируются с учетом размещения их в Docker контейнере.

Масштабирование и мониторинг
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Горизонтальное масштабирование системы осуществляется как на уровне микросервисов (запуск копий сервисов, реплицирование/шардирование БД), 
так и на уровне всей инфраструктуры месссенджера для "приближения" ее к географически распределенным клиентам.

Мониторинг работоспособности системы оcуществляется с применением Prometheus для сбора метрик и Grafana для отображения и оповещений.

Логирование осуществляется с применением паттерна Log aggregation в Elasticsearch с визуализацией данных в Kibana.

Основные сервисы системы
~~~~~~~~~~~~~~~~~~~~~~~~~~

Websocket сервис 
""""""""""""""""""

Геораспредленные сревисы, в обязанности которых входит предоставление порта каждому онлайн-пользователю.

API-шлюз (API Gateway)
"""""""""""""""""""""""""

Позволяет инкапсулировать внутреннюю архитектуру мессенджера, а так же осуществляет функции аутентификации запросов.
Шлюз выполняет только аутентификацию и маршрутизацию запросов. В случае необходимости, шлюз расширяется функциями композита. 
Система содержит API-шлюзы под каждый тип клиента (пользователь, администратор и т.п.).

Websocket менеджер (WebSocket manager)
"""""""""""""""""""""""""""""""""""""""

Отвечает за поддержание соответствия между серверами, пользователями и портами.

Служба сообщений (Message service)
"""""""""""""""""""""""""""""""""""

Служба сообщений - это хранилище сообщений поверх кластера баз данных. Она действует как интерфейс к базе данных для других служб. 
Отвечает за хранение и извлечение сообщений из базы данных. Также удаляет сообщения из базы данных через заданный промежуток времени. 
Предоставляет API для получения сообщений с помощью различных фильтров, таких как идентификатор клиента, идентификатор сообщения и так далее.

Служба оповещений (Notification service)
""""""""""""""""""""""""""""""""""""""""""

Отвечает за отправку push-уведомлений.

Служба статусов (Statuses service)
"""""""""""""""""""""""""""""""""""""

Отслеживает статус посещения пользователей. 

Мультимедиа сервис (Asset service)
"""""""""""""""""""""""""""""""""""""

Сервис отвечает за отправку и получение медиафайлов. 

Сервис профилей пользователей (User service)
""""""""""""""""""""""""""""""""""""""""""""""

Отвечает за управление клиентами системы.


Контекстная диаграмма системы
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. uml:: petchatContext.puml
    :scale: 100 %
    :align: center


Диаграммы последовательности
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Он-лайн взаимодействие Клиент - Клиент
""""""""""""""""""""""""""""""""""""""""

Шаги связи между двумя клиентами:

- Клиент 1 и Клиент 2 создают канал связи с сервером мессенджера.
- Клиент 1 отправляет сообщение на сервер мессенджера.
- После получения сообщения сервер мессенджера подтверждает ответ Клиенту 1.
- Сервер мессенджера отправляет сообщение Клиенту 2 и сохраняет сообщение в базе данных, если статус получателя не в сети.
- Клиент 2 отправляет подтверждение на сервер мессенджера.
- Сервер мессенджера уведомляет Клиента 1 об успешной доставке сообщения.
- Когда Клиент 2 читает сообщение, приложение уведомляет об этом сервер мессенджера.
- Сервер мессенджера уведомляет Клиента 1 о том, что Клиент 2 прочитал сообщение.

.. uml:: petchatSequence.puml
    :scale: 100%
    :align: center